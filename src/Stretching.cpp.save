//      _____         __        __                               ____                                        __
//     / ___/ ____ _ / /____   / /_   __  __ _____ ____ _       / __ \ ___   _____ ___   ____ _ _____ _____ / /_
//     \__ \ / __ `// //_  /  / __ \ / / / // ___// __ `/      / /_/ // _ \ / ___// _ \ / __ `// ___// ___// __ \
//    ___/ // /_/ // /  / /_ / /_/ // /_/ // /   / /_/ /      / _, _//  __/(__  )/  __// /_/ // /   / /__ / / / /
//   /____/ \__,_//_/  /___//_.___/ \__,_//_/    \__, /      /_/ |_| \___//____/ \___/ \__,_//_/    \___//_/ /_/
//                                              /____/
//   Salzburg Research ForschungsgesmbH
//
//  Dominik Hofer, Michaela Mühlberger, Armin Niedermueller

//  DTZ ROS Robot Demonstrator
//  The purpose of this program is to control the panda robot via ros
//  It gets its TODOs via a rostopic from the opcua panda server

#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>

#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>

#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>

#include <moveit_visual_tools/moveit_visual_tools.h>
#include <control_msgs/GripperCommandAction.h>
#include <franka_gripper/franka_gripper.h>

#include <ros/ros.h>
#include <ros/console.h>

#include "std_msgs/String.h"
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>

#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <cstdlib>

#include <thread>
#include <sys/socket.h>
#include <arpa/inet.h>


std::string global_moving{"false"};
std::string global_order_movement{"XX"};
std::string global_response{"none"};
std_msgs::String global_ros_response;
int global_order_pos{0};
int global_temperature;

namespace rvt = rviz_visual_tools;


////////////////////////////////////////////////  ROBOT ROS METHODS  ///////////////////////////////////////////////////

void chatterCallback(const std_msgs::String::ConstPtr& msg){
    ROS_INFO("I heard: [%s]", msg->data.c_str());

    // create and initialize a stringstream object with our string
    std::stringstream ss{msg->data.c_str()};

    // split the string into to arguments
    ss >> global_order_movement;    // PO
    ss >> global_order_pos;         // 3


}


void moveFunction(std::vector<double> joint_group_positions, const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed, Eigen::Affine3d text_pose){

    move_group->setJointValueTarget(joint_group_positions);

    moveit::planning_interface::MoveGroupInterface::Plan my_plan;

    bool success = (move_group->plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
    ROS_INFO_NAMED("tutorial", "Visualizing plan 1 (joint space goal) %s", success ? "" : "FAILED");

    move_group->setMaxVelocityScalingFactor(speed);

    visual_tools.deleteAllMarkers();
    visual_tools.publishText(text_pose, "Joint Space Goal", rvt::WHITE, rvt::XLARGE);
    visual_tools.publishTrajectoryLine(my_plan.trajectory_, joint_model_group);
    visual_tools.trigger();
    visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");

    move_group->move();

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveToInitialPosition(const robot_state::JointModelGroup* joint_model_group,
                           moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -0.038238,		 // Joint 1 
        -0.536294,		 // Joint 2 
        -0.000188,		 // Joint 3 
        -2.645116,		 // Joint 4 
        -0.004514,		 // Joint 5 
        +2.135098,		 // Joint 6 
        +0.787146		 // Joint 7 
        };


            

    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveToPrinter(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    // Fängt an das Objekt vom Drucker zu heben

    std::vector<double> joint_group_positions;

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);
    
    joint_group_positions =
        {
        -2.508229,		 // Joint 1 
        +0.656498,		 // Joint 2 
        -0.440398,		 // Joint 3 
        -1.554039,		 // Joint 4 
        +0.927285,		 // Joint 5 
        +2.087697,		 // Joint 6 
        -0.944861		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    // Position direkt beim Drucker
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -2.516322,		 // Joint 1 
        +1.032788,		 // Joint 2 
        -0.322207,		 // Joint 3 
        -1.286464,		 // Joint 4 
        +1.095004,		 // Joint 5 
        +2.246536,		 // Joint 6 
        -0.998115		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveFromPrinter(const robot_state::JointModelGroup* joint_model_group,
                     moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    // Fängt an das Objekt vom Drucker zu heben

    // Erste Position
    std::vector<double> joint_group_positions;

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -2.542509,		 // Joint 1 
        +0.990563,		 // Joint 2 
        -0.307504,		 // Joint 3 
        -1.285260,		 // Joint 4 
        +1.104788,		 // Joint 5 
        +2.166730,		 // Joint 6 
        -0.978925		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -2.509485,		 // Joint 1 
        +0.801865,		 // Joint 2 
        -0.324251,		 // Joint 3 
        -1.375549,		 // Joint 4 
        +1.003452,		 // Joint 5 
        +2.132986,		 // Joint 6 
        -0.893283		 // Joint 7 
        };

    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveToOutput(const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){
    
    std::vector<double> joint_group_positions;

    // Position 50cm über Förderband
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        +0.844795,		 // Joint 1 
        -0.384217,		 // Joint 2 
        +1.890267,		 // Joint 3 
        -1.501299,		 // Joint 4 
        +0.146468,		 // Joint 5 
        +1.830871,		 // Joint 6 
        +2.016475		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    // Ablege-Position beim Förderband
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        +0.857302,		 // Joint 1 
        -1.322565,		 // Joint 2 
        +2.104476,		 // Joint 3 
        -1.837629,		 // Joint 4 
        +0.304724,		 // Joint 5 
        +2.699032,		 // Joint 6 
        +2.333015		 // Joint 7 
        };







    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveFromOutput(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    // Erste Position
    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        +0.844795,		 // Joint 1 
        -0.384217,		 // Joint 2 
        +1.890267,		 // Joint 3 
        -1.501299,		 // Joint 4 
        +0.146468,		 // Joint 5 
        +1.830871,		 // Joint 6 
        +2.016475		 // Joint 7 
        };





    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveToStorage(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){ // Passt
// Hier ne Position um vor dem Regal zu "Schweben"
    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.253866,		 // Joint 1 
        -1.317198,		 // Joint 2 
        -0.736604,		 // Joint 3 
        -2.692074,		 // Joint 4 
        -0.386493,		 // Joint 5 
        +3.027500,		 // Joint 6 
        +0.478003		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Alle 9 Funktionen, die für das Finden des richtigen Lagerplatzes gedacht sind, fahren folgendes Muster:
// *Von Regal schwebend zu Platz schwebend
// *Von Platz schwebend zu ablegen/aufnehmen
// *Von ablegen/aufnehmen zu Platz schwebend

bool findPlaceOne(const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.511856,		 // Joint 1 
        -0.735951,		 // Joint 2 
        -0.162523,		 // Joint 3 
        -2.388369,		 // Joint 4 
        -0.252198,		 // Joint 5 
        +2.794242,		 // Joint 6 
        +0.962948		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.507024,		 // Joint 1 
        -0.349107,		 // Joint 2 
        -0.186876,		 // Joint 3 
        -2.108088,		 // Joint 4 
        -0.210574,		 // Joint 5 
        +2.792832,		 // Joint 6 
        +0.933140		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

bool leavePlaceOne(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.523155,		 // Joint 1 
        -0.791830,		 // Joint 2 
        -0.126194,		 // Joint 3 
        -2.161597,		 // Joint 4 
        -0.141906,		 // Joint 5 
        +2.368946,		 // Joint 6 
        +0.807658		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
    return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceTwo(const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.525840,		 // Joint 1 
        -0.547715,		 // Joint 2 
        -0.359663,		 // Joint 3 
        -2.115587,		 // Joint 4 
        -0.038640,		 // Joint 5 
        +2.515810,		 // Joint 6 
        +0.597984		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.507753,		 // Joint 1 
        -0.262268,		 // Joint 2 
        -0.381431,		 // Joint 3 
        -1.889730,		 // Joint 4 
        +0.224483,		 // Joint 5 
        +2.459141,		 // Joint 6 
        +0.367193		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

bool leavePlaceTwo(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.526461,		 // Joint 1 
        -0.897823,		 // Joint 2 
        -0.325643,		 // Joint 3 
        -2.198928,		 // Joint 4 
        -0.085243,		 // Joint 5 
        +2.264202,		 // Joint 6 
        +0.585285		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceThree(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.234043,		 // Joint 1 
        -0.633994,		 // Joint 2 
        -0.777248,		 // Joint 3 
        -1.919269,		 // Joint 4 
        +0.033815,		 // Joint 5 
        +2.337780,		 // Joint 6 
        +0.215133		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.154926,		 // Joint 1 
        -0.072466,		 // Joint 2 
        -0.980329,		 // Joint 3 
        -1.647465,		 // Joint 4 
        +0.550544,		 // Joint 5 
        +2.325004,		 // Joint 6 
        -0.021841		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void leavePlaceThree(const robot_state::JointModelGroup* joint_model_group,
                     moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.405916,		 // Joint 1 
        -0.871457,		 // Joint 2 
        -0.590374,		 // Joint 3 
        -1.798350,		 // Joint 4 
        -0.095836,		 // Joint 5 
        +1.887347,		 // Joint 6 
        +0.353584		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceSeven(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.622442,		 // Joint 1 
        -0.197166,		 // Joint 2 
        -0.031049,		 // Joint 3 
        -2.828259,		 // Joint 4 
        +0.033588,		 // Joint 5 
        +3.717884,		 // Joint 6 
        +0.746824		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.735426,		 // Joint 1 
        +0.090972,		 // Joint 2 
        -0.036559,		 // Joint 3 
        -2.559284,		 // Joint 4 
        -0.254167,		 // Joint 5 
        +3.712037,		 // Joint 6 
        +0.904257		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

bool leavePlaceSeven(const robot_state::JointModelGroup* joint_model_group,
                     moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.735277,		 // Joint 1 
        -0.727342,		 // Joint 2 
        -0.074803,		 // Joint 3 
        -3.038172,		 // Joint 4 
        -0.220031,		 // Joint 5 
        +3.598844,		 // Joint 6 
        +0.940405		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceEight(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -0.762530,		 // Joint 1 
        -0.520953,		 // Joint 2 
        -1.225208,		 // Joint 3 
        -2.809085,		 // Joint 4 
        -0.126767,		 // Joint 5 
        +3.741283,		 // Joint 6 
        +0.348710		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -0.096707,		 // Joint 1 
        -0.450126,		 // Joint 2 
        -1.818301,		 // Joint 3 
        -2.499406,		 // Joint 4 
        -0.077739,		 // Joint 5 
        +3.596749,		 // Joint 6 
        +0.329274		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

bool leavePlaceEight(const robot_state::JointModelGroup* joint_model_group,
                     moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.567161,		 // Joint 1 
        -1.091034,		 // Joint 2 
        -0.616020,		 // Joint 3 
        -2.856120,		 // Joint 4 
        -0.402183,		 // Joint 5 
        +2.559800,		 // Joint 6 
        +0.582130		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceNine(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -0.848283,		 // Joint 1 
        -0.570500,		 // Joint 2 
        -1.370628,		 // Joint 3 
        -2.390296,		 // Joint 4 
        -0.321502,		 // Joint 5 
        +2.855108,		 // Joint 6 
        +0.348224		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -0.221307,		 // Joint 1 
        -0.601533,		 // Joint 2 
        -1.878757,		 // Joint 3 
        -2.160085,		 // Joint 4 
        -0.332949,		 // Joint 5 
        +3.019382,		 // Joint 6 
        +0.357786		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void leavePlaceNine(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.447198,		 // Joint 1 
        -1.266130,		 // Joint 2 
        -0.938800,		 // Joint 3 
        -2.640395,		 // Joint 4 
        -0.634035,		 // Joint 5 
        +2.326707,		 // Joint 6 
        +0.464244		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceFour(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.459702,		 // Joint 1 
        -0.761496,		 // Joint 2 
        -0.264955,		 // Joint 3 
        -2.664676,		 // Joint 4 
        -0.185350,		 // Joint 5 
        +2.947302,		 // Joint 6 
        +0.843715		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.431767,		 // Joint 1 
        -0.286003,		 // Joint 2 
        -0.244478,		 // Joint 3 
        -2.371593,		 // Joint 4 
        +0.025203,		 // Joint 5 
        +2.967458,		 // Joint 6 
        +0.677537		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void leavePlaceFour(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.627621,		 // Joint 1 
        -1.025556,		 // Joint 2 
        -0.126263,		 // Joint 3 
        -2.732278,		 // Joint 4 
        -0.044615,		 // Joint 5 
        +2.559199,		 // Joint 6 
        +0.746667		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceFive(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.549007,		 // Joint 1 
        -0.544233,		 // Joint 2 
        -0.385146,		 // Joint 3 
        -2.459377,		 // Joint 4 
        +0.122135,		 // Joint 5 
        +2.741727,		 // Joint 6 
        +0.372972		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.487383,		 // Joint 1 
        -0.187960,		 // Joint 2 
        -0.396331,		 // Joint 3 
        -2.172568,		 // Joint 4 
        +0.296937,		 // Joint 5 
        +2.712695,		 // Joint 6 
        +0.328158		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void leavePlaceFive(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.646722,		 // Joint 1 
        -1.053110,		 // Joint 2 
        -0.376471,		 // Joint 3 
        -2.573094,		 // Joint 4 
        +0.025246,		 // Joint 5 
        +2.557058,		 // Joint 6 
        +0.395910		 // Joint 7 
        };



    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findPlaceSix(const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.430820,		 // Joint 1 
        -0.435938,		 // Joint 2 
        -0.704007,		 // Joint 3 
        -2.229647,		 // Joint 4 
        +0.400800,		 // Joint 5 
        +2.660224,		 // Joint 6 
        -0.047453		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.277079,		 // Joint 1 
        -0.066632,		 // Joint 2 
        -0.821599,		 // Joint 3 
        -2.024405,		 // Joint 4 
        +0.901283,		 // Joint 5 
        +2.652458,		 // Joint 6 
        -0.377069		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void leavePlaceSix(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){

    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.652634,		 // Joint 1 
        -0.920197,		 // Joint 2 
        -0.619455,		 // Joint 3 
        -2.368886,		 // Joint 4 
        +0.193585,		 // Joint 5 
        +2.462501,		 // Joint 6 
        -0.008289		 // Joint 7 
        };


    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool findRightSpot(const robot_state::JointModelGroup* joint_model_group,
                   moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, int place, moveit::core::RobotStatePtr current_state){


// Hier die Abfrage
// wenn 1 - 3: oberes Regal
//    auf Position des jeweiligen Plates fahren (davor schweben)
//    auf Ablageposition des Plates fahren und Gripper öffnen
// wenn 4 - 6: keine Änderung
//    auf Position des jeweiligen Plates fahren (davor schweben)
//    auf Ablageposition des Plates fahren und Gripper öffnen
// wenn 7 - 9: unteres Regal fahren
//    auf Position des jeweiligen Plates fahren (davor schweben)
//    auf Ablageposition des Plates fahren und Gripper öffnenbool notCorrectPosition = true;


    if (place < 4) {
// Hier Position für erstes Fach
        std::vector<double> joint_group_positions;
        current_state = move_group->getCurrentState();
        current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

        joint_group_positions =
            {
            -2.036547,		 // Joint 1 
            -0.676776,		 // Joint 2 
            +0.028436,		 // Joint 3 
            -2.264860,		 // Joint 4 
            +0.742554,		 // Joint 5 
            +2.537966,		 // Joint 6 
            +0.010293		 // Joint 7 
            };



        moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);


        if(place == 1) {
            findPlaceOne(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else if(place == 2) {
            // Hier Position für zweiten Platz
            findPlaceTwo(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else{
            // Hier Position für dritten Platz
            findPlaceThree(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
    }
    else if (place > 6) {
// Hier Position für drittes Fach
        std::vector<double> joint_group_positions;
        current_state = move_group->getCurrentState();
        current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

        joint_group_positions =
            {
            -1.916964,		 // Joint 1 
            -0.787211,		 // Joint 2 
            -0.169726,		 // Joint 3 
            -2.843623,		 // Joint 4 
            +1.094392,		 // Joint 5 
            +2.755166,		 // Joint 6 
            -0.637992		 // Joint 7 
            };




        moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

        if(place == 7) {
            findPlaceSeven(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

        }
        else if(place == 8) {
            findPlaceEight(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

        }
        else{
            findPlaceNine(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

        }
    }
    else {

        if(place == 4) {
            findPlaceFour(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else if(place == 5) {
            findPlaceFive(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else{
            findPlaceSix(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
    }
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool leaveRightSpot(const robot_state::JointModelGroup* joint_model_group,
                    moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, int place, moveit::core::RobotStatePtr current_state){

    if (place < 4) {
        if(place == 1) {
            leavePlaceOne(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else if(place == 2) {
            leavePlaceTwo(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else{
            leavePlaceThree(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
    }
    else if (place > 6) {
        if(place == 7) {
            leavePlaceSeven(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else if(place == 8) {
            leavePlaceEight(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else{
            leavePlaceNine(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
    }
    else {

        if(place == 4) {
            leavePlaceFour(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else if(place == 5) {
            leavePlaceFive(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
        else{
            leavePlaceSix(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
        }
    }
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool moveFromStorage(const robot_state::JointModelGroup* joint_model_group,
                     moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, int place, moveit::core::RobotStatePtr current_state){

    /*
    if (place < 4) {
// Hier Position für erstes Fach
        std::vector<double> joint_group_positions;
        current_state = move_group->getCurrentState();
        current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

        joint_group_positions =
            {
            -1.274421,		 // Joint 1 
            -1.484182,		 // Joint 2 
            -0.509653,		 // Joint 3 
            -2.539459,		 // Joint 4 
            -0.653390,		 // Joint 5 
            +2.489574,		 // Joint 6 
            +0.893266		 // Joint 7 
            };



        moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    }
    else if (place > 6) {
// Hier Position für drittes Fach
        std::vector<double> joint_group_positions;
        current_state = move_group->getCurrentState();
        current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

        joint_group_positions =
            {
            -1.499604,		 // Joint 1 
            -1.694284,		 // Joint 2 
            -0.715597,		 // Joint 3 
            -2.957918,		 // Joint 4 
            -0.779736,		 // Joint 5 
            +2.568088,		 // Joint 6 
            +0.867862		 // Joint 7 
            };


        moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    }
    */

// In Schwebeposition zurück fahren
    std::vector<double> joint_group_positions;
    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        -1.499604,		 // Joint 1 
        -1.694284,		 // Joint 2 
        -0.715597,		 // Joint 3 
        -2.957918,		 // Joint 4 
        -0.779736,		 // Joint 5 
        +2.568088,		 // Joint 6 
        +0.867862		 // Joint 7 
        };




    moveFunction(joint_group_positions, joint_model_group, move_group, visual_tools, speed, text_pose);

    return true;
}

void openGripper(actionlib::SimpleActionClient<franka_gripper::StopAction> *acs,
                 actionlib::SimpleActionClient<franka_gripper::MoveAction> *acm,
                 franka_gripper::StopGoal goalS, franka_gripper::MoveGoal goalM){
    acs->sendGoal(goalS);
    goalM.width = 0.08;
    goalM.speed = 0.1;
    acm->sendGoal(goalM);
}

void closeGripper(actionlib::SimpleActionClient<franka_gripper::GraspAction> *acg, franka_gripper::GraspGoal goalG){
    goalG.width = 0.04;
    goalG.speed = 0.1;
    goalG.force = 60;
    goalG.epsilon.inner = 0.05;
    goalG.epsilon.outer = 0.05;
    acg->sendGoal(goalG);
}

void homeGripper(actionlib::SimpleActionClient<franka_gripper::HomingAction> *ach, franka_gripper::HomingGoal goal){
    ach->sendGoal(goal);
    sleep(5);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ShowToCamera(const robot_state::JointModelGroup* joint_model_group,
                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,   Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state){
    // show object to camera
    std::vector<double> joint_group_positions;

    current_state = move_group->getCurrentState();
    current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

    joint_group_positions =
        {
        +0.861129,		 // Joint 1 
        +0.835717,		 // Joint 2 
        +0.199601,		 // Joint 3 
        -0.577428,		 // Joint 4 
        -0.169529,		 // Joint 5 
        +3.432604,		 // Joint 6 
        +0.994774		 // Joint 7 
        };




    sleep(1);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool getBlockFromPrinterToOutput(const robot_state::JointModelGroup* joint_model_group,
                                 moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools,
                                 float speed, Eigen::Affine3d text_pose, moveit::core::RobotStatePtr current_state,
                                 actionlib::SimpleActionClient<franka_gripper::GraspAction> *acg, actionlib::SimpleActionClient<franka_gripper::StopAction> *acs,
                                 actionlib::SimpleActionClient<franka_gripper::MoveAction> *acm, franka_gripper::GraspGoal goalG,
                                 franka_gripper::StopGoal goalS, franka_gripper::MoveGoal goalM){


    moveToPrinter(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    closeGripper(acg, goalG);
    sleep(1);

    moveFromPrinter(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    ShowToCamera(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    moveToOutput(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    openGripper(acs, acm, goalS, goalM);
    sleep(1);

    moveFromOutput(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    moveToInitialPosition(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool getBlockFromPrinterToStorage(const robot_state::JointModelGroup* joint_model_group,
                                  moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools,
                                  float speed,   Eigen::Affine3d text_pose, int place, moveit::core::RobotStatePtr current_state,
                                  actionlib::SimpleActionClient<franka_gripper::GraspAction> *acg, actionlib::SimpleActionClient<franka_gripper::StopAction> *acs,
                                  actionlib::SimpleActionClient<franka_gripper::MoveAction> *acm, franka_gripper::GraspGoal goalG,
                                  franka_gripper::StopGoal goalS, franka_gripper::MoveGoal goalM){

    moveToPrinter(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    closeGripper(acg, goalG);
    sleep(1);

    moveFromPrinter(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    ShowToCamera(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    moveToStorage(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    findRightSpot(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);
    openGripper(acs, acm, goalS, goalM);
    sleep(1);

    leaveRightSpot(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);
    moveFromStorage(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);

    moveToInitialPosition(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool getBlockFromStorageToOutput(const robot_state::JointModelGroup* joint_model_group,
                                 moveit::planning_interface::MoveGroupInterface* move_group, moveit_visual_tools::MoveItVisualTools visual_tools, float speed,
                                 Eigen::Affine3d text_pose, int place, moveit::core::RobotStatePtr current_state,
                                 actionlib::SimpleActionClient<franka_gripper::GraspAction> *acg, actionlib::SimpleActionClient<franka_gripper::StopAction> *acs,
                                 actionlib::SimpleActionClient<franka_gripper::MoveAction> *acm, franka_gripper::GraspGoal goalG,
                                 franka_gripper::StopGoal goalS, franka_gripper::MoveGoal goalM){

    moveToStorage(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    findRightSpot(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);
    closeGripper(acg, goalG);
    sleep(1);

    leaveRightSpot(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);
    moveFromStorage(joint_model_group, move_group, visual_tools, speed, text_pose, place, current_state);
    ShowToCamera(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    moveToOutput(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    openGripper(acs, acm, goalS, goalM);
    sleep(1);

    moveFromOutput(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);
    moveToInitialPosition(joint_model_group, move_group, visual_tools, speed, text_pose, current_state);

    return true;
}

//////////////////////////////////////////////  M A I N  ///////////////////////////////////////////////////////////////
int main(int argc, char** argv)
{
    ////////////////// INIT //////////////////
    // ROS INIT
    ros::init(argc, argv, "Stretching");
    ros::NodeHandle node_handle;
    ros::Subscriber sub = node_handle.subscribe("ros_opcua_order", 1000, chatterCallback);
    ros::Publisher pub = node_handle.advertise<std_msgs::String>("ros_opcua_response", 1000);

    ros::AsyncSpinner spinner(1);
    spinner.start();

    // PANDA INIT
    static const std::string PLANNING_GROUP = "panda_arm";

    moveit::planning_interface::MoveGroupInterface move_group(PLANNING_GROUP);

    const robot_state::JointModelGroup* joint_model_group =
            move_group.getCurrentState()->getJointModelGroup(PLANNING_GROUP);

    moveit_visual_tools::MoveItVisualTools visual_tools("panda_link0");
    visual_tools.deleteAllMarkers();
    visual_tools.loadRemoteControl();

    Eigen::Affine3d text_pose = Eigen::Affine3d::Identity();
    text_pose.translation().z() = 1.75;
    visual_tools.publishText(text_pose, "Z_FirstTry Demo", rvt::WHITE, rvt::XLARGE);

    visual_tools.trigger();

    ROS_INFO_NAMED("tutorial", "Reference frame: %s", move_group.getPlanningFrame().c_str());
    ROS_INFO_NAMED("tutorial", "End effector link: %s", move_group.getEndEffectorLink().c_str());
    visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to start the demo");

    double speed = 0.4;
    moveit::core::RobotStatePtr current_state;

    actionlib::SimpleActionClient<franka_gripper::GraspAction> acg("franka_gripper/grasp", true);
    actionlib::SimpleActionClient<franka_gripper::StopAction> acs("franka_gripper/stop", true);
    actionlib::SimpleActionClient<franka_gripper::MoveAction> acm("franka_gripper/move", true);
    actionlib::SimpleActionClient<franka_gripper::HomingAction> ach("franka_gripper/homing", true);
    // actionlib::SimpleActionClient<franka_control::ErrorRecoveryAction> era("franka_control/errorRecovery", true);

    ROS_INFO("Waiting for action server to start.");
    //wait for the action server to start
    acg.waitForServer(); //will wait for infinite time
    acs.waitForServer();
    acm.waitForServer();
    ach.waitForServer();
    // era.waitForServer();
    ROS_INFO("Action server started, sending goal.");
    franka_gripper::GraspGoal goalG;
    franka_gripper::StopGoal goalS;
    franka_gripper::MoveGoal goalM;
    franka_gripper::HomingGoal goalH;
    // franka_control::ErrorRecoveryActionGoal goalError;

    // openGripper(&acs, &acm, goalS, goalM);

    ///////////////// MAIN LOOP //////////////////
    try{

        while(ros::ok()) {

            ////////////////// RECEIVING ORDERS //////////////////
            if (global_order_movement.compare("PS") == 0 || global_order_movement.compare("SO") == 0) {

                std::cout << "Place: " << global_order_pos << std::endl;

                // check if place is supported (must be between 1 and 9)
                if (global_order_pos < 1 || global_order_pos > 9) {
                    // std::cout << "Place not supported!" << std::endl;
                    global_order_movement = "XX";
                    global_order_pos = 0;
                    continue;
                }
            } else if (global_order_movement.compare("XX") == 0) {
                continue;
            }

            // publish state
            global_response = "Moving";
            // This is the Response from the robot if it is moving or not, necessary for the opcua master to wait until "stopped"
            // so that it could run the conveyor belt
            global_ros_response.data = global_response;
            pub.publish(global_ros_response);

            // try{
                ////////////////// MOVEMENT OF ROBOT //////////////////
                if (global_order_movement.compare("PO") == 0) {
                    homeGripper(&ach, goalH);
                    getBlockFromPrinterToOutput(joint_model_group, &move_group, visual_tools, speed, text_pose,
                                                current_state, &acg, &acs, &acm, goalG, goalS, goalM);
                } else if (global_order_movement.compare("PS") == 0) {
                    homeGripper(&ach, goalH);
                    getBlockFromPrinterToStorage(joint_model_group, &move_group, visual_tools, speed, text_pose, global_order_pos,
                                                current_state, &acg, &acs, &acm, goalG, goalS, goalM);
                } else if (global_order_movement.compare("SO") == 0) {
                    homeGripper(&ach, goalH);
                    getBlockFromStorageToOutput(joint_model_group, &move_group, visual_tools, speed, text_pose, global_order_pos,
                                                current_state, &acg, &acs, &acm, goalG, goalS, goalM);
                }
            // }catch(const std::exception& e){
            //     era.sendGoal(goalError);
            // }

            // publish state
            global_response = "Stopped";
            // This is the Response from the robot if it is moving or not, necessary for the opcua master to wait until "stopped"
            // so that it could run the conveyor belt
            global_ros_response.data = global_response;
            pub.publish(global_ros_response);

            // Reset Position, otherwise robot would move in an endless loop
            global_order_pos = 0;

            sleep(2);
        }

    } catch(const std::exception& e){
        std::cout << "Catched Exception: " << e.what() << " - stopping program" << std::endl;
        ros::shutdown();
        return 0;
    }
}

